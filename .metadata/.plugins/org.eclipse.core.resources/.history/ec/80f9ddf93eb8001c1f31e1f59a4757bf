package section_one;

import java.math.BigInteger;
import java.util.Comparator;

public class Bruch implements Comparable<Bruch>{
	
	// attributes
	private int zaehler;
	private int nenner;
	
	// constructor
	public Bruch(int zaehler, int nenner) throws ArithmeticException{
		this.zaehler = zaehler;
		try {
			setNenner(nenner);	
		} 
		catch (ArithmeticException e) {
			System.out.println("Attention! " + e);
		}

	}

	public int getZaehler() {
		return zaehler;
	}

	public void setZaehler(int zaehler) {
		this.zaehler = zaehler;
	}

	public int getNenner() {
		return nenner;
	}

	public void setNenner(int nenner) throws ArithmeticException {
		if(nenner == 0) {
			this.nenner = 1;
			throw new ArithmeticException("Dividing through 0 is not allowed. The value got set to 1 instead.");
		}
		else {
			this.nenner = nenner;						
		}
	}
	
//	liefert eine String-Darstellung des Bruches
	public String toString() {
		return "Bruch: " + this.zaehler + "/" + this.nenner + "\n";
	}
	
//	rechnet this * b
	public Bruch multiplizieren(Bruch b) {
		Bruch bruch = new Bruch(this.zaehler * b.getZaehler(), this.nenner * b.getNenner());
		return bruch;
	}
	
//	rechnet den Bruch in eine Kommazahl um
	public double ausrechnen() {
		return (double) this.getZaehler()/this.getNenner();
	}
	
//	 kürzt this, d.h. Zähler und Nenner werden durch deren größten gemeinsamen Teiler 
//	 geteilt. (Es gibt in der Klasse BigInteger die Methode gcd() oder Sie benutzen 
//	 den euklidischen Algorithmus, um den größten gemeinsamen Teiler zu bestimmen.)
	public void kuerzen() {
		BigInteger zaehler = BigInteger.valueOf(this.zaehler);
		BigInteger nenner = BigInteger.valueOf(this.nenner);
		BigInteger gcd = zaehler.gcd(nenner);
		this.zaehler = this.zaehler / gcd.intValue();
		this.nenner = this.nenner / gcd.intValue();
	}
	
//	 liefert den Kehrwert von this zurück
	public Bruch kehrwert() {
		Bruch kehrwert = new Bruch(this.nenner, this.zaehler);
		return kehrwert;
	}
	
//	 teilt this durch b und gibt das Ergebnis zurück. Rufen Sie die bisher geschriebenen 
//	 Funktionen multiplizieren() und kehrwert() auf, denn Dividieren heißt mathematisch multiplizieren mit dem Kehrwert.
	public Bruch dividieren(Bruch b) {
		return multiplizieren(b.kehrwert());
	}
	
	@Override
	public int compareTo(Bruch bruch) {
		float value1 = this.zaehler / this.nenner;
		float value2 = bruch.zaehler / bruch.nenner;
		if(value1 < value2) {
			return -1;
		} 
		else if(value1 > value2) {
			return 1;
		}
		return 0;
	}
	
	@Override
	public int compareTo(Bruch bruch) {
		float value1 = this.zaehler / this.nenner;
		float value2 = bruch.zaehler / bruch.nenner;
		if(value1 < value2) {
			return -21;
		} 
		else if(value1 > value2) {
			return 1;
		}
		return 0;
	}
}
